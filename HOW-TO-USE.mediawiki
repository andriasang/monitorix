__NOTOC__
= Introduction =

You can add monitorix to any existing Zend Framework project, it doesn't interfere with your usual error and exception handling. The setup is extremely simple.


= Details =

==Files==
The downloadable bundle contains mainly the following files:

* Monitor.php
* MonitorExceptions.php
* MonitorJavascript.php
* MonitorSlowQueries.php
* Version.php
* monitorix.sql

===Monitor.php===
This is the main class of the component.

===MonitorExceptions.php===
This is a Controller Plugin needed to monitor Exceptions.

===MonitorJavascript.php===
This is a Controller Plugin needed to monitor javascript errors.

===MonitorSlowQueries.php===
This is a Controller Plugin needed to monitor slow database queries.

===monitorix.sql===
You find this under /docs. You can run it to setup the needed database, table(s) and user permissions for monitorix. Read the instructions in the file.

=File system=
We advise you to use the bundle as provided as an additional library.
<pre>
 docs
 |_LICENSE
 |_INSTRUCTIONS
 |_monitorix.sql 

 library
 |_Monitorix
   |_Controller
     |_Plugin
       |_MonitorExceptions.php
       |_MonitorJavascript.php
       |_MonitorSlowQueries.php
 |_Monitor.php
 |_Version.php
</pre>
=Setup steps=
# Add the 'Monitorix' folder to your library folder or use a Symlink
# Add  'Monitorix_' to your namespaces.
# Create the database, the table and the user with the help of monitorix.sql
# Add the following connection block to your application.ini
<pre>
resources.monitor.db.adapter = "Pdo_Mysql"
resources.monitor.db.params.username = "monitorix"
resources.monitor.db.params.password = "yourmonitorixpassword"
resources.monitor.db.params.dbname = "monitorix"
</pre>
# Add the following lines of code to your Bootstrap.php
<pre>
protected function _initMonitor()
{
    $config = Zend_Registry::get('config');
    $monitorDb = Zend_Db::factory($config->resources->monitor->db->adapter, $config->resources->monitor->db->params);

    $monitor = new Monitorix_Monitor(new Zend_Log_Writer_Db($monitorDb, 'logentries'), "yourProjectName");
        
    //if you want to monitor php errors
    $monitor->registerErrorHandler();

    //if you want to monitor fatal errors and syntax errors
    $monitor->logFatalErrors();

    //if you want to log exceptions
    $monitor->logExceptions();

    //if you want to monitor javascript errors
    $monitor->logJavascriptErrors();

    //if you want to log slow database queries
    $monitor->logSlowQueries(array($dbAdapter));
}
</pre>

monitorix provides a fluid interface, so you could also write:
<pre>
$monitor->registerErrorHandler()->logFatalErrors()->logExceptions()->logSlowQueries(array($dbAdapter));
</pre>

=Usage=
==General==
monitorix will attempt to set the 'environment' field automatically by using the APPLICATION_ENV constant. If this constant is not defined (should be) it will log everything with the default value of "undefined". You can also set the value in your bootstrap or elsewhere with:
<pre>
$monitor->setEnvironment('development');
</pre>

Also, if you don't pass a project name when you setup the monitorix instance, you can later set it with:
<pre>
$monitor->setProjectName('myProjectName');
</pre>

==Logging PHP errors==
monitorix automatically logs PHP errors for you, if you use:
<pre>
$monitor->registerErrorHandler();
</pre>

PHP errors are logged according to the 8 priorities documented in !Zend_Log. monitorix has a field 'logType'. For logged PHP errors this field will contain the string "php error".

==Logging fatal PHP errors==
monitorix automatically logs the last PHP error before shutdown/exit, if  you use:
<pre>
$monitor->logFatalErrors();
</pre>

Such errors are a subclass of the "php error" type with a special context information "Last error before shutdown. Fatal or syntax.".

==Logging Exceptions==
monitorix automagically logs all Exceptions that bubble up to the surface (ancaught Exceptions) if you set:
<pre>
$monitor->logExceptions();
</pre>

Exceptions are logged with priority '2 = CRIT'. The field 'logType' will contain the string "exception".

==Logging Javascript Errors==
monitorix automagically logs all javascript errors that are not caught during execution, if you set:

<pre>
$monitor->logJavascriptErrors();
</pre>

monitorix will attempt to automatically:

  # init the view, if it can't be retrieved from the viewRenderer
  # register the jQuery view helper, if not registered already
  # enable jQuery, if it is not enabled yet

If monitorix should fail to enable jQuery, it will throw a !Monitorix_Exception. If you have a custom implementation of jQuery, you can suppress step 2 and 3 of this list by passing FALSE as second parameter. 
<pre>
$monitor->logJavascriptErrors(TRUE, FALSE);
</pre>
The view has to be available though, so that monitorix can prepend its 'window.onerror' script.

==Logging Slow Database Queries==
monitorix automagically logs all database queries that take longer than 1 second or any other value you pass, if you set:
<pre>
$monitor->logSlowQueries(array($myDbAdapter, $myOtherDbAdapter), 0.5);
</pre>

As first parameter you can pass an array of as many Zend_Db_Adapter instances as you wish. Normally you'll probably have one.

As second argument, you can pass a limit in seconds. Every query which takes longer than that, will be logged.

==Logging other events==
With monitorix you can log whaterver you want, wherever you want.
Here a few examples:

<pre>
//get the monitorix instance from the registry
$monitor = Zend_Registry::get('monitor');

//log a simple message, it will be logged with the default priority 7 = DEBUG and the 'logType' "simpleLog"
$monitor->writeLog('A simple message');

//log a message with a custom 'logType' and a custom priority
$monitor->writeLog('A special message', 5, 'myCustomLogType');

//set your own default log type
$monitor->setDefaultLogType('myDefault');

//and then log to this type simply with
$monitor->writeLog('this will be logged with my new default logType');
</pre>